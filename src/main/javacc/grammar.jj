/*
 * Copyright (C) 2007-2010 JÃºlio Vilmar Gesser.
 * Copyright (C) 2011, 2013-2015 The JavaParser Team.
 * Copyright (C) 2011, 2015 Didier Villevalois.
 *
 * This file is part of JLaTo.
 *
 * JLaTo is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JLaTo is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JLaTo.  If not, see <http://www.gnu.org/licenses/>.
 */

options {
  LOOKAHEAD = 1;
  JAVA_UNICODE_ESCAPE = true;

  JDK_VERSION = "1.6";

  //SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
  STATIC = false;

  COMMON_TOKEN_ACTION = true;
  TOKEN_MANAGER_USES_PARSER = true;

  TOKEN_EXTENDS = "org.jlato.parser.ParserBase.TokenBase";
}

PARSER_BEGIN(ParserImpl)
/*
 * Copyright (C) 2015 Didier Villevalois.
 *
 * This file is part of JLaTo.
 *
 * JLaTo is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JLaTo is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JLaTo.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.jlato.parser;

import java.io.*;
import java.util.*;
import org.jlato.internal.bu.*;
import org.jlato.tree.*;
import org.jlato.tree.decl.*;
import org.jlato.tree.expr.*;
import org.jlato.tree.name.*;
import org.jlato.tree.stmt.*;
import org.jlato.tree.type.*;
import org.jlato.internal.bu.*;

/**
 * <p>This class was generated automatically by javacc, do not edit.</p>
 */
final class ParserImpl extends ParserBase {

    void reset(InputStream inputStream, String encoding) {
        ReInit(inputStream, encoding);
        reset();
    }

    void reset(Reader reader) {
        ReInit(reader);
        reset();
    }

    private void throwParseException(Token token, String message) throws ParseException {
        StringBuilder buf = new StringBuilder();
        buf.append(message);
        buf.append(": '");
        buf.append(token.image);
        buf.append("' at line ");
        buf.append(token.beginLine);
        buf.append(", column ");
        buf.append(token.beginColumn);
        ParseException e = new ParseException(buf.toString());
        e.currentToken = token;
        throw e;
    }
}

PARSER_END(ParserImpl)

TOKEN_MGR_DECLS:{

	void CommonTokenAction(Token token) {
		parser.postProcessToken(token);
	}
}

/* WHITE SPACE */

SPECIAL_TOKEN :
{
  <WHITESPACE: (" " | "\t")+ >
}

SPECIAL_TOKEN :
{
  <NEWLINE: ("\n" | "\r" | "\f" | "\r\n") >
}

/* COMMENTS */

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* >
}

MORE :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_JAVA_DOC_COMMENT
|
  <"/*"> : IN_MULTI_LINE_COMMENT
}

<IN_JAVA_DOC_COMMENT>
SPECIAL_TOKEN :
{
  <JAVA_DOC_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* LITERALS */

TOKEN :
{
  < LONG_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])
      | <HEX_LITERAL> (["l","L"])
      | <OCTAL_LITERAL> (["l","L"])
      | <BINARY_LITERAL> (["l","L"])
  >
|
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      | <BINARY_LITERAL>
  >
|
  < #DECIMAL_LITERAL: (["0"-"9"]((["0"-"9","_"])*["0"-"9"])?) >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"]((["0"-"9","a"-"f","A"-"F","_"])*["0"-"9","a"-"f","A"-"F"])?) >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"]((["0"-"7","_"])*["0"-"7"])?) >
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0","1"]((["0","1","_"])*["0","1"])?) >
|
  < FLOAT_LITERAL:
        <DECIMAL_FLOAT_LITERAL>
      | <HEXADECIMAL_FLOAT_LITERAL>
  >
|
  < DOUBLE_LITERAL:
        <DECIMAL_DOUBLE_LITERAL>
      | <HEXADECIMAL_DOUBLE_LITERAL>
  >
|
  < #FLOAT_SUFFIX: ["f","F"] >
|
  < #DOUBLE_SUFFIX: ["d","D"] >
|
  < #DECIMAL_FLOAT_LITERAL:
        (<DECIMAL_LITERAL>)+ "." (<DECIMAL_LITERAL>)* (<DECIMAL_EXPONENT>)? <FLOAT_SUFFIX>
      | "." (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? <FLOAT_SUFFIX>
      | (<DECIMAL_LITERAL>)+ <DECIMAL_EXPONENT> <FLOAT_SUFFIX>
      | (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? <FLOAT_SUFFIX>
  >
|
  < #DECIMAL_DOUBLE_LITERAL:
        (<DECIMAL_LITERAL>)+ "." (<DECIMAL_LITERAL>)* (<DECIMAL_EXPONENT>)? (<DOUBLE_SUFFIX>)?
      | "." (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? (<DOUBLE_SUFFIX>)?
      | (<DECIMAL_LITERAL>)+ <DECIMAL_EXPONENT> (<DOUBLE_SUFFIX>)?
      | (<DECIMAL_LITERAL>)+ (<DECIMAL_EXPONENT>)? <DOUBLE_SUFFIX>
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (<DECIMAL_LITERAL>)+ >
|
  < #HEXADECIMAL_FLOAT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> <FLOAT_SUFFIX>
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> <FLOAT_SUFFIX>
  >
|
  < #HEXADECIMAL_DOUBLE_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (<DOUBLE_SUFFIX>)?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (<DOUBLE_SUFFIX>)?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
        	["0"-"9","A"-"F","a"-"f"]
          )
      )*
      "\""
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < ARROW: "->" >
| < DOUBLECOLON : "::">
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     matchedToken.realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     matchedToken.realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}

/* QUOTE VARIABLES */

TOKEN :
{
  < NODE_VARIABLE:
    "\u0024"          // "$"
    (<PART_LETTER>)*
  >
  {
    if (!parser.quotesMode) matchedToken.kind = IDENTIFIER;
  }
|
  < NODE_LIST_VARIABLE:
    ".."
    "\u0024"          // "$"
    (<PART_LETTER>)*
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         //"\u0024",          // "$"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u066e"-"\u066f",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06ee"-"\u06ef",
         "\u06fa"-"\u06fc",
         "\u06ff",
         "\u0710",
         "\u0712"-"\u072f",
         "\u074d"-"\u074f",
         "\u0780"-"\u07a5",
         "\u07b1",
         "\u0904"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bd",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0"-"\u0ae1",
         "\u0af1",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b71",
         "\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bf9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbd",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1711",
         "\u1720"-"\u1731",
         "\u1740"-"\u1751",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1780"-"\u17b3",
         "\u17d7",
         "\u17db"-"\u17dc",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1900"-"\u191c",
         "\u1950"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "\u0024",          // "$"
         "\u0030"-"\u0039", // "0"-"9"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00ad",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u0357",
         "\u035d"-"\u036f",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0600"-"\u0603",
         "\u0610"-"\u0615",
         "\u0621"-"\u063a",
         "\u0640"-"\u0658",
         "\u0660"-"\u0669",
         "\u066e"-"\u06d3",
         "\u06d5"-"\u06dd",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06fc",
         "\u06ff",
         "\u070f"-"\u074a",
         "\u074d"-"\u074f",
         "\u0780"-"\u07b1",
         "\u0901"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a01"-"\u0a03",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0"-"\u0ae3",
         "\u0ae6"-"\u0aef",
         "\u0af1",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b71",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0bf9",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbc"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1714",
         "\u1720"-"\u1734",
         "\u1740"-"\u1753",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1772"-"\u1773",
         "\u1780"-"\u17d3",
         "\u17d7",
         "\u17db"-"\u17dd",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180d",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1900"-"\u191c",
         "\u1920"-"\u192b",
         "\u1930"-"\u193b",
         "\u1946"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2060"-"\u2063",
         "\u206a"-"\u206f",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u20e5"-"\u20ea",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u3099"-"\u309a",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\ud834", //for supplementary characters suport
         "\udc00", //for supplementary characters suport
         "\udc01", //for supplementary characters suport
         "\udd7b", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe00"-"\ufe0f",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >
}

/**********************************************************************************************************************
 * Quote variables
 **********************************************************************************************************************/

STree<SNodeListState> NodeListVar():{}
{
  <NODE_LIST_VARIABLE>
  { return makeVar(); }
}

STree<Name.State> NodeVar():{}
{
  <NODE_VARIABLE>
  { return makeVar(); }
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

STree<CompilationUnit.State> CompilationUnit():
{
	STree<PackageDecl.State> packageDecl = null;
	STree<SNodeListState> imports;
	STree<SNodeListState> types;
	STree<CompilationUnit.State> compilationUnit;
}
{
  { run(); }

  [ LOOKAHEAD(PackageDecl()) packageDecl = PackageDecl() ]
  imports = ImportDecls()
  types = TypeDecls()

  { compilationUnit = dress(CompilationUnit.make(packageDecl, imports, types)); }

  Epilog()
  { return dressWithPrologAndEpilog(compilationUnit); }
}

void Epilog(): {}
{
  (<EOF> | "\u001A" /** ctrl+z char **/)
}


/**********************************************************************************************************************
 * Declarations
 **********************************************************************************************************************/

STree<PackageDecl.State> PackageDecl():
{
	STree<SNodeListState> annotations = null;
	STree<QualifiedName.State> name;
}
{
  { run(); }

  annotations = Annotations() "package" name = QualifiedName() ";"

  { return dress(PackageDecl.make(annotations, name)); }
}

STree<SNodeListState> ImportDecls():
{
	STree<SNodeListState> imports = emptyList();
	STree<ImportDecl.State> importDecl = null;
}
{
  ( importDecl = ImportDecl() { imports = append(imports, importDecl); } )*
  { return imports; }
}

STree<ImportDecl.State> ImportDecl():
{
	STree<QualifiedName.State> name;
	boolean isStatic = false;
	boolean isAsterisk = false;
}
{
  { run(); }
  "import" [ "static" { isStatic = true; } ] name = QualifiedName() [ "." "*" { isAsterisk = true; } ] ";"
  { return dress(ImportDecl.make(name, isStatic, isAsterisk)); }
}

STree<SNodeListState> TypeDecls():
{
	STree<SNodeListState> types = emptyList();
	STree<? extends TypeDecl.State> typeDecl = null;
}
{
  ( typeDecl = TypeDecl() { types = append(types, typeDecl); } )*
  { return types; }
}

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */

STree<SNodeListState> Modifiers():
{
	STree<SNodeListState> modifiers = emptyList();
	STree<? extends AnnotationExpr.State> ann;
}
{
  (
    LOOKAHEAD(2)
    (
      "public" { modifiers = append(modifiers, Modifier.make(LToken.Public)); }
    |
      "protected" { modifiers = append(modifiers, Modifier.make(LToken.Protected)); }
    |
      "private" { modifiers = append(modifiers, Modifier.make(LToken.Private)); }
    |
      "abstract" { modifiers = append(modifiers, Modifier.make(LToken.Abstract)); }
    |
      "default" { modifiers = append(modifiers, Modifier.make(LToken.Default)); }
    |
      "static" { modifiers = append(modifiers, Modifier.make(LToken.Static)); }
    |
      "final" { modifiers = append(modifiers, Modifier.make(LToken.Final)); }
    |
      "transient" { modifiers = append(modifiers, Modifier.make(LToken.Transient)); }
    |
      "volatile" { modifiers = append(modifiers, Modifier.make(LToken.Volatile)); }
    |
      "synchronized" { modifiers = append(modifiers, Modifier.make(LToken.Synchronized)); }
    |
      "native" { modifiers = append(modifiers, Modifier.make(LToken.Native)); }
    |
      "strictfp" { modifiers = append(modifiers, Modifier.make(LToken.StrictFP)); }
    |
      ann = Annotation() { modifiers = append(modifiers, ann); }
    )
  )*

  { return modifiers; }
}

/*
 * Decl syntax follows.
 */
STree<? extends TypeDecl.State> TypeDecl():
{
	STree<SNodeListState> modifiers;
	STree<? extends TypeDecl.State> ret;
}
{
  { run(); }

  (
    ";" { ret = dress(EmptyTypeDecl.make()); }
  |
    modifiers = Modifiers()
    (
      ret = ClassOrInterfaceDecl(modifiers)
    |
      ret = EnumDecl(modifiers)
    |
      ret = AnnotationTypeDecl(modifiers)
    )
  )

  { return ret; }
}


STree<? extends TypeDecl.State> ClassOrInterfaceDecl(STree<SNodeListState> modifiers):
{
	TypeKind typeKind;
	STree<Name.State> name;
	STree<SNodeListState> typeParams = null;
	STree<QualifiedType.State> superClassType = null;
	STree<SNodeListState> extendsClause = null;
	STree<SNodeListState> implementsClause = null;
	STree<SNodeListState> members;
}
{
  // Run is started before modifiers

  (
    "class" { typeKind = TypeKind.Class; }
    name = Name()
    [ typeParams = TypeParameters() ]
    [ "extends" superClassType = AnnotatedQualifiedType() ]
    [ implementsClause = ImplementsList(typeKind) ]
  |
    "interface" { typeKind = TypeKind.Interface; }
    name = Name()
    [ typeParams = TypeParameters() ]
    [ extendsClause = ExtendsList() ]
    [ implementsClause = ImplementsList(typeKind) ]
  )
  members = ClassOrInterfaceBody(typeKind)

  {
    if (typeKind == TypeKind.Interface)
      return dress(InterfaceDecl.make(modifiers, name, ensureNotNull(typeParams), ensureNotNull(extendsClause), members));
    else {
      return dress(ClassDecl.make(modifiers, name, ensureNotNull(typeParams), optionOf(superClassType), ensureNotNull(implementsClause), members));
    }
  }
}

STree<SNodeListState> ExtendsList():
{
	STree<SNodeListState> ret = emptyList();
	STree<QualifiedType.State> cit;
	STree<SNodeListState> annotations = null;
}
{
  "extends"
  (
    cit = AnnotatedQualifiedType() { ret = append(ret, cit); }
    ( "," cit = AnnotatedQualifiedType() { ret = append(ret, cit); } )*
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  )
  { return ret; }
}

STree<SNodeListState> ImplementsList(TypeKind typeKind):
{
	STree<SNodeListState> ret = emptyList();
	STree<QualifiedType.State> cit;
	STree<SNodeListState> annotations = null;
}
{
  "implements"
  (
    cit = AnnotatedQualifiedType() { ret = append(ret, cit); }
    ( "," cit = AnnotatedQualifiedType() { ret = append(ret, cit); } )*
    {
      if (typeKind == TypeKind.Interface)
        throwParseException(token, "An interface cannot implement other interfaces");
    }
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  )
  { return ret; }
}

STree<? extends TypeDecl.State> EnumDecl(STree<SNodeListState> modifiers):
{
	STree<Name.State> name;
	STree<SNodeListState> implementsClause = emptyList();
	STree<EnumConstantDecl.State> entry;
	STree<SNodeListState> constants = emptyList();
	boolean trailingComma = false;
	STree<SNodeListState> members = null;
}
{
  // Run is started before modifiers

  "enum" name = Name() [ implementsClause = ImplementsList(TypeKind.Enum) ]
  "{"
  [
    entry = EnumConstantDecl() { constants = append(constants, entry); }
    ( LOOKAHEAD(2) "," entry = EnumConstantDecl() { constants = append(constants, entry); } )*
  |
    LOOKAHEAD({quotesMode}) constants = NodeListVar()
  ]
  [ "," { trailingComma = true; } ]
  [ ";" members = ClassOrInterfaceBodyDecls(TypeKind.Enum) ]
  "}"

  { return dress(EnumDecl.make(modifiers, name, implementsClause, constants, trailingComma, ensureNotNull(members))); }
}

STree<EnumConstantDecl.State> EnumConstantDecl():
{
	STree<SNodeListState> modifiers = null;
	STree<Name.State> name;
	STree<SNodeListState> args = null;
	STree<SNodeListState> classBody = null;
}
{
  { run(); }

  modifiers = Modifiers() name = Name()
  [ args = Arguments() ] [ classBody = ClassOrInterfaceBody(TypeKind.Class) ]

  { return dress(EnumConstantDecl.make(modifiers, name, optionOf(args), optionOf(classBody))); }
}

STree<AnnotationDecl.State> AnnotationTypeDecl(STree<SNodeListState> modifiers):
{
	STree<Name.State> name;
	STree<SNodeListState> members;
}
{
  // Run is started before modifiers

  "@" "interface" name = Name()
  members = AnnotationTypeBody()

  { return dress(AnnotationDecl.make(modifiers, name, members)); }
}

// TODO Merge with ClassOrInterfaceBody production and do later checks programmaticaly
STree<SNodeListState> AnnotationTypeBody():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends MemberDecl.State> member;
}
{
  "{"
  [
    ( member = AnnotationTypeBodyDecl() { ret = append(ret, member); } )+
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  ]
  "}"
  { return ret; }
}

// TODO Merge with ClassOrInterfaceDecl production and do later checks programmaticaly
STree<? extends MemberDecl.State> AnnotationTypeBodyDecl():
{
	STree<SNodeListState> modifiers;
	STree<? extends MemberDecl.State> ret;
}
{
  { run(); }

  (
	";" { ret = dress(EmptyTypeDecl.make()); }
  |
    modifiers = Modifiers()
    (
      LOOKAHEAD(Type() Name() "(")
      ret = AnnotationTypeMemberDecl(modifiers)
    |
      ret = ClassOrInterfaceDecl(modifiers)
    |
      ret = EnumDecl(modifiers)
    |
      ret = AnnotationTypeDecl(modifiers)
    |
      ret = FieldDecl(modifiers)
    )
  )

  { return ret; }
}

// TODO Merge with MethodDecl production and do later checks programmaticaly
STree<AnnotationMemberDecl.State> AnnotationTypeMemberDecl(STree<SNodeListState> modifiers):
{
	STree<? extends Type.State> type;
	STree<Name.State> name;
	STree<SNodeListState> dims;
	STree<SNodeOptionState> defaultVal = none();
	STree<? extends Expr.State> val = null;
}
{
  // Run is started before modifiers

  type = Type(null) name = Name() "(" ")" dims = ArrayDims()
  [
    "default" val = MemberValue()
    { defaultVal = optionOf(val); }
  ]
  ";"

  { return dress(AnnotationMemberDecl.make(modifiers, type, name, dims, defaultVal)); }
}

STree<SNodeListState> TypeParameters():
{
	STree<SNodeListState> ret = emptyList();
	STree<TypeParameter.State> tp;
}
{
  "<"
  (
    tp = TypeParameter() { ret = append(ret, tp); }
    ( "," tp = TypeParameter() { ret = append(ret, tp); } )*
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  )
  ">"

  { return ret; }
}

STree<TypeParameter.State> TypeParameter():
{
	STree<SNodeListState> annotations = null;
	STree<Name.State> name;
	STree<SNodeListState> typeBounds = null;
}
{
  { run(); }
  annotations = Annotations() name = Name() [ typeBounds = TypeBounds() ]
  { return dress(TypeParameter.make(annotations, name, ensureNotNull(typeBounds))); }
}

STree<SNodeListState> TypeBounds():
{
	STree<SNodeListState> ret = emptyList();
	STree<QualifiedType.State> cit;
	STree<SNodeListState> annotations = null;
}
{
  "extends"
  (
    cit = AnnotatedQualifiedType() { ret = append(ret, cit); }
    ( "&" cit = AnnotatedQualifiedType() { ret = append(ret, cit); } )*
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  )
  { return ret; }
}

STree<SNodeListState> ClassOrInterfaceBody(TypeKind typeKind):
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends MemberDecl.State> member;
}
{
  "{"
  ret = ClassOrInterfaceBodyDecls(typeKind)
  "}"
  { return ret; }
}

STree<SNodeListState> ClassOrInterfaceBodyDecls(TypeKind typeKind):
{
	STree<? extends MemberDecl.State> member;
	STree<SNodeListState> ret = emptyList();
}
{
  [
    ( member = ClassOrInterfaceBodyDecl(typeKind) { ret = append(ret, member); } )+
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  ]
  { return ret; }
}

STree<? extends MemberDecl.State> ClassOrInterfaceBodyDecl(TypeKind typeKind):
{
	STree<SNodeListState> modifiers;
	STree<? extends MemberDecl.State> ret;
}
{
  { run(); }

  (
    ";" { ret = dress(EmptyMemberDecl.make()); }
  |
    modifiers = Modifiers()
    {
      if (modifiers != null && contains(modifiers, Modifier.make(LToken.Default)) && typeKind != TypeKind.Interface)
        throwParseException(token, "Only interfaces can have default members");
    }
    (
      LOOKAHEAD( "{" )
      ret = InitializerDecl(modifiers)
      {
        if (typeKind == TypeKind.Interface)
	      throwParseException(token, "An interface cannot have initializers");
	  }
    |
      ret = ClassOrInterfaceDecl(modifiers)
    |
      ret = EnumDecl(modifiers)
    |
      ret = AnnotationTypeDecl(modifiers)
    |
      LOOKAHEAD( [ TypeParameters() ] Name() "(" )
      ret = ConstructorDecl(modifiers)
      {
        if (typeKind == TypeKind.Interface)
	      throwParseException(token, "An interface cannot have constructors");
	  }
    |
      LOOKAHEAD( Type() Name() ( "[" "]" )* ( "," | "=" | ";" ) )
      ret = FieldDecl(modifiers)
    |
      ret = MethodDecl(modifiers)
    )
  )

  { return ret; }
}

STree<FieldDecl.State> FieldDecl(STree<SNodeListState> modifiers):
{
	STree<? extends Type.State> type;
	STree<SNodeListState> variables = emptyList();
	STree<VariableDeclarator.State> val;
}
{
  // Run is started before modifiers

  type = Type(null) variables = VariableDeclarators() ";"

  { return dress(FieldDecl.make(modifiers, type, variables)); }
}

STree<LocalVariableDecl.State> VariableDecl(STree<SNodeListState> modifiers):
{
	STree<? extends Type.State> type;
	STree<SNodeListState> variables = emptyList();
}
{
  // Run is started before modifiers

  type = Type(null) variables = VariableDeclarators()

  { return dress(LocalVariableDecl.make(modifiers, type, variables)); }
}

STree<SNodeListState> VariableDeclarators():
{
	STree<SNodeListState> variables = emptyList();
	STree<VariableDeclarator.State> val;
}
{
        val = VariableDeclarator() { variables = append(variables, val); }
  ( "," val = VariableDeclarator() { variables = append(variables, val); } )*

  { return variables; }
}

STree<VariableDeclarator.State> VariableDeclarator():
{
	STree<VariableDeclaratorId.State> id;
	STree<SNodeOptionState> init = none();
	STree<? extends Expr.State> initExpr = null;
}
{
  { run(); }

  id = VariableDeclaratorId()
  [
    "=" initExpr = VariableInitializer()
    { init = optionOf(initExpr); }
  ]

  { return dress(VariableDeclarator.make(id, init)); }
}

STree<VariableDeclaratorId.State> VariableDeclaratorId():
{
	STree<Name.State> name;
	STree<SNodeListState> arrayDims;
}
{
  { run(); }

  name = Name() arrayDims = ArrayDims()

  { return dress(VariableDeclaratorId.make(name, arrayDims)); }
}

STree<SNodeListState> ArrayDims():
{
	STree<SNodeListState> arrayDims = emptyList();
	STree<SNodeListState> annotations;
}
{
  (
    LOOKAHEAD( Annotations() "[" "]" )
    { run(); }
    annotations = Annotations() "[" "]"
    { arrayDims = append(arrayDims, dress(ArrayDim.make(annotations))); }
  )*
  { return arrayDims; }
}

STree<? extends Expr.State> VariableInitializer():
{
	STree<? extends Expr.State> ret;
}
{
  ( ret = ArrayInitializer() | ret = Expression() )
  { return ret; }
}

STree<ArrayInitializerExpr.State> ArrayInitializer():
{
	STree<SNodeListState> values = emptyList();
	STree<? extends Expr.State> val;
	boolean trailingComma = false;
}
{
  { run(); }
  "{"
  [
    val = VariableInitializer() { values = append(values, val); }
    ( LOOKAHEAD(2) "," val = VariableInitializer() { values = append(values, val); } )*
  ]
  [ "," { trailingComma = true; } ]
  "}"

  { return dress(ArrayInitializerExpr.make(values, trailingComma)); }
}

STree<MethodDecl.State> MethodDecl(STree<SNodeListState> modifiers):
{
	STree<SNodeListState> typeParameters = null;
	STree<? extends Type.State> type;
	STree<Name.State> name;
	STree<SNodeListState> parameters;
	STree<SNodeListState> arrayDims;
	STree<SNodeListState> throwsClause = null;
	STree<BlockStmt.State> block = null;
}
{
  // Run is started before modifiers

  [ typeParameters = TypeParameters() ]
  type = ResultType()
  name = Name() parameters = FormalParameters() arrayDims = ArrayDims()
  [ throwsClause = ThrowsClause() ]
  (
    block = Block()
  |
    ";"
    {
      if(modifiers != null && contains(modifiers, Modifier.make(LToken.Default)))
	    throwParseException(token, "default methods must have a body");
	}
  )

  { return dress(MethodDecl.make(modifiers, ensureNotNull(typeParameters), type, name, parameters, arrayDims, ensureNotNull(throwsClause), optionOf(block))); }
}

STree<SNodeListState> FormalParameters():
{
	STree<SNodeListState> ret = null;
	STree<FormalParameter.State> par;
}
{
  "("
  [
    ret = FormalParameterList()
  ]
  ")"
  { return ensureNotNull(ret); }
}

STree<SNodeListState> FormalParameterList():
{
	STree<SNodeListState> ret = null;
	STree<FormalParameter.State> par;
}
{
  (
    par = FormalParameter() { ret = append(ret, par); }
    ( "," par = FormalParameter() { ret = append(ret, par); } )*
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  )
  { return ret; }
}

STree<FormalParameter.State> FormalParameter():
{
	STree<SNodeListState> modifiers;
	STree<? extends Type.State> type;
	boolean isVarArg = false;
	STree<VariableDeclaratorId.State> id;
}
{
  { run(); }

  modifiers = Modifiers() type = Type(null) [ "..." { isVarArg = true; } ] id = VariableDeclaratorId()

  { return dress(FormalParameter.make(modifiers, type, isVarArg, id)); }
}


STree<SNodeListState> ThrowsClause():
{
	STree<SNodeListState> ret = emptyList();
	STree<QualifiedType.State> cit;
}
{
  "throws" cit = AnnotatedQualifiedType() { ret = append(ret, cit); }
  ( "," cit = AnnotatedQualifiedType() { ret = append(ret, cit); } )*

  { return ret; }
}

STree<ConstructorDecl.State> ConstructorDecl(STree<SNodeListState> modifiers):
{
	STree<SNodeListState> typeParameters = null;
	STree<Name.State> name;
	STree<SNodeListState> parameters;
	STree<SNodeListState> throwsClause = null;
	STree<ExplicitConstructorInvocationStmt.State> exConsInv = null;
	STree<BlockStmt.State> block;
	STree<SNodeListState> stmts = emptyList();
	STree<? extends Stmt.State> stmt;
}
{
  // Run is started before modifiers

  [ typeParameters = TypeParameters() ]
  name = Name() parameters = FormalParameters()
  [ throwsClause = ThrowsClause() ]

  { run(); }
  "{"
  [
    LOOKAHEAD(2)
    (
      LOOKAHEAD(ExplicitConstructorInvocation()) stmt = ExplicitConstructorInvocation() { stmts = append(stmts, stmt); }
    |
      LOOKAHEAD(2) stmt = BlockStatement() { stmts = append(stmts, stmt); }
    )
    ( LOOKAHEAD(2) stmt = BlockStatement() { stmts = append(stmts, stmt); } )*
  |
    LOOKAHEAD({quotesMode}) stmts = NodeListVar()
  ]
  "}"
  { block = dress(BlockStmt.make(stmts)); }

  { return dress(ConstructorDecl.make(modifiers, ensureNotNull(typeParameters), name, parameters, ensureNotNull(throwsClause), block)); }
}

STree<ExplicitConstructorInvocationStmt.State> ExplicitConstructorInvocation():
{
	boolean isThis = false;
	STree<SNodeListState> args;
	STree<? extends Expr.State> expr = null;
	STree<SNodeListState> typeArgs = null;
}
{
  { run(); }

  (
    LOOKAHEAD([ TypeArguments() ] "this" "(")
    [ typeArgs = TypeArguments() ]
    "this" { isThis = true; }
    args = Arguments() ";"
  |
    [
      LOOKAHEAD( PrimaryExpressionWithoutSuperSuffix() "." )
      expr = PrimaryExpressionWithoutSuperSuffix() "."
    ]
    [ typeArgs = TypeArguments() ]
    "super"
    args = Arguments() ";"
  )

  { return dress(ExplicitConstructorInvocationStmt.make(ensureNotNull(typeArgs), isThis, optionOf(expr), args)); }
}

STree<SNodeListState> Statements():
{
	STree<SNodeListState> ret = null;
	STree<? extends Stmt.State> stmt;
}
{
  [
    LOOKAHEAD(2)
    (
      ( LOOKAHEAD(2) stmt = BlockStatement() { ret = append(ret, stmt); } )+
    |
      LOOKAHEAD({quotesMode}) ret = NodeListVar()
    )
  ]
  { return ret; }
}

STree<InitializerDecl.State> InitializerDecl(STree<SNodeListState> modifiers):
{
	STree<BlockStmt.State> block;
}
{
  // Run is started before modifiers

  block = Block()

  { return dress(InitializerDecl.make(modifiers, block)); }
}


/**********************************************************************************************************************
 * Types
 **********************************************************************************************************************/

STree<? extends Type.State> Type(STree<SNodeListState> annotations):
{
	STree<? extends Type.State> ret;
}
{
  // Run may be started before annotations

  (
    LOOKAHEAD(2) ret = ReferenceType(annotations)
  |
    ret = PrimitiveType(annotations)
  )
  { return ret; }
}

STree<? extends ReferenceType.State> ReferenceType(STree<SNodeListState> annotations):
{
	STree<? extends Type.State> primitiveType;
	STree<? extends ReferenceType.State> type;
	STree<SNodeListState> arrayDims;
}
{
  // Run may be started before annotations

  (
    LOOKAHEAD(2)
    primitiveType = PrimitiveType(annotations)
    { lateRun(); }
    arrayDims = ArrayDimsMandatory()
    { type = dress(ArrayType.make(primitiveType, arrayDims)); }
  |
    type = QualifiedType(annotations)
    [
      LOOKAHEAD(2)
      { lateRun(); }
      arrayDims = ArrayDimsMandatory()
      { type = dress(ArrayType.make(type, arrayDims)); }
    ]
  )

  { return type; }
}

STree<QualifiedType.State> QualifiedType(STree<SNodeListState> annotations):
{
    STree<SNodeOptionState> scope = none();
	STree<QualifiedType.State> ret;
	STree<Name.State> name;
	STree<SNodeListState> typeArgs = null;
}
{
  // Run may be started before annotations
  {
    if (annotations == null) {
      run();
      annotations = emptyList();
    }
  }

  name = Name()
  [ LOOKAHEAD(2) typeArgs = TypeArgumentsOrDiamond() ]
  { ret = dress(QualifiedType.make(annotations, scope, name, optionOf(typeArgs))); }
  (
    LOOKAHEAD(2)
    "." { scope = optionOf(ret); }

    { lateRun(); }
    annotations = Annotations() name = Name()
    [ LOOKAHEAD(2) typeArgs = TypeArgumentsOrDiamond() ]
    { ret = dress(QualifiedType.make(annotations, scope, name, optionOf(typeArgs))); }
  )*

  { return ret; }
}

STree<SNodeListState> TypeArguments():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Type.State> type;
}
{
  "<"
  [ ret = TypeArgumentList() ]
  ">"
  { return ret; }
}


STree<SNodeListState> TypeArgumentsOrDiamond():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Type.State> type;
}
{
  "<"
  [ ret = TypeArgumentList() ]
  ">"
  { return ret; }
}

STree<SNodeListState> TypeArgumentList():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Type.State> type;
}
{
  type = TypeArgument() { ret = append(ret, type); }
  ( "," type = TypeArgument() { ret = append(ret, type); } )*
  { return ret; }
|
  LOOKAHEAD({quotesMode})
  <NODE_LIST_VARIABLE> { return makeVar(); }
}

STree<? extends Type.State> TypeArgument():
{
	STree<? extends Type.State> ret;
	STree<SNodeListState> annotations = null;
}
{
  { run(); }
  annotations = Annotations()
  (
    ret = ReferenceType(annotations)
  |
    ret = Wildcard(annotations)
  )
  { return ret; }
}

STree<WildcardType.State> Wildcard(STree<SNodeListState> annotations):
{
	STree<? extends ReferenceType.State> ext = null;
	STree<? extends ReferenceType.State> sup = null;
	STree<SNodeListState> boundAnnotations = null;
}
{
  // Run may be started before annotations
  {
    if (annotations == null) {
      run();
      annotations = emptyList();
    }
  }

  "?"
  [ "extends" { run(); } boundAnnotations = Annotations() ext = ReferenceType(boundAnnotations)
  | "super" { run(); } boundAnnotations = Annotations() sup = ReferenceType(boundAnnotations) ]
  { return dress(WildcardType.make(annotations, optionOf(ext), optionOf(sup))); }
}

STree<PrimitiveType.State> PrimitiveType(STree<SNodeListState> annotations):
{
	PrimitiveType.Primitive primitive;
}
{
  // Run may be started before annotations
  {
    if (annotations == null) {
      run();
      annotations = emptyList();
    }
  }

  ( "boolean" { primitive = PrimitiveType.Primitive.Boolean; }
  | "char"    { primitive = PrimitiveType.Primitive.Char; }
  | "byte"    { primitive = PrimitiveType.Primitive.Byte; }
  | "short"   { primitive = PrimitiveType.Primitive.Short; }
  | "int"     { primitive = PrimitiveType.Primitive.Int; }
  | "long"    { primitive = PrimitiveType.Primitive.Long; }
  | "float"   { primitive = PrimitiveType.Primitive.Float; }
  | "double"  { primitive = PrimitiveType.Primitive.Double; } )
  { return dress(PrimitiveType.make(annotations, primitive)); }
}

STree<? extends Type.State> ResultType():
{
	STree<? extends Type.State> ret;
}
{
  (
    { run(); } "void" { ret = dress(VoidType.make()); }
  |
    ret = Type(null)
  )
  { return ret; }
}

STree<SNodeListState> QualifiedTypeList():
{
	STree<SNodeListState> ret = emptyList();
	STree<QualifiedType.State> type;
}
{
  { run(); }

  type = AnnotatedQualifiedType() { ret = append(ret, type); }
  ( "," type = AnnotatedQualifiedType() { ret = append(ret, type); } )*

  { return dress(ret); }
}

STree<QualifiedType.State> AnnotatedQualifiedType():
{
    STree<SNodeListState> annotations;
	STree<QualifiedType.State> ret;
}
{
  { run(); }
  annotations = Annotations() ret = QualifiedType(annotations)
  { return ret; }
}

/**********************************************************************************************************************
 * Names
 **********************************************************************************************************************/

STree<QualifiedName.State> QualifiedName():
{
    STree<SNodeOptionState> qualifier = none();
	STree<QualifiedName.State> ret = null;
	STree<Name.State> name;
}
{
  { run(); } name = Name() { ret = dress(QualifiedName.make(qualifier, name)); }
  (
    LOOKAHEAD(2)
    { lateRun(); }
    "." { qualifier = optionOf(ret); }
    name = Name() { ret = dress(QualifiedName.make(qualifier, name)); }
  )*
  { return ret; }
}

STree<Name.State> Name():
{
    STree<Name.State> name;
}
{
  (
    { run(); }
    <IDENTIFIER>
    { name = dress(Name.make(token.image)); }
  |
    LOOKAHEAD({quotesMode}) name = NodeVar()
  )
  { return name; }
}

/**********************************************************************************************************************
 * Expressions
 **********************************************************************************************************************/

STree<? extends Expr.State> Expression():
// FIXME
// This expansion has been written this way instead of :
//   Assignment() | ConditionalExpression()
// for performance reasons.
// However, it is a weakening of the grammar for it allows the LHS of
// assignments to be any conditional Expr whereas it can only be
// a primary Expr.  Consider adding a semantic predicate to work
// around this.
{
	STree<? extends Expr.State> ret;
	AssignExpr.AssignOp op;
	STree<? extends Expr.State> value;
	STree<SNodeListState> params;
}
{
  (
    LOOKAHEAD( Name() "->" )
    { run(); } ret = Name() "->" ret = LambdaBody(singletonList(makeFormalParameter((STree<Name.State>) ret)), false)
  |
    LOOKAHEAD( "(" ")" "->" )
    { run(); } "(" ")" "->" ret = LambdaBody(emptyList(), true)
  |
    LOOKAHEAD( "(" Name() ")" "->" )
    { run(); } "(" ret = Name() ")" "->" ret = LambdaBody(singletonList(makeFormalParameter((STree<Name.State>) ret)), true)
  |
    LOOKAHEAD( "(" Name() "," )
    { run(); } "(" params = InferredFormalParameterList() ")" "->" ret = LambdaBody(params, true)
  |
    ret = ConditionalExpression()
    [
      LOOKAHEAD(2)
      { lateRun(); } op = AssignmentOperator() value = Expression()
      { ret = dress(AssignExpr.make(ret, op, value)); }
    ]
  )
  { return ret; }
}

STree<LambdaExpr.State> LambdaBody(STree<SNodeListState> parameters, boolean parenthesis):
{
	STree<BlockStmt.State> block;
	STree<? extends Expr.State> expr;
	STree<LambdaExpr.State> ret;
}
{
  // Run was started before parameters
  (
    expr = Expression() { ret = dress(LambdaExpr.make(parameters, parenthesis, left(expr))); }
  |
    block = Block() { ret = dress(LambdaExpr.make(parameters, parenthesis, right(block))); }
  )
  { return ret; }
}

STree<SNodeListState> LambdaParameters(ByRef<Boolean> parenthesis):
{
	STree<SNodeListState> ret;
	STree<FormalParameter.State> param;
}
{
  (
    { run(); }
    param = InferredFormalParameter()
    {
      parenthesis.value = false;
      ret = dress(singletonList(param));
    }
  |
    "("
    (
      LOOKAHEAD(InferredFormalParameterList()) ret = InferredFormalParameterList()
    |
      ret = FormalParameterList()
    )
    ")"
    { parenthesis.value = true; }
  )
  { return ret; }
}

STree<SNodeListState> InferredFormalParameterList():
{
	STree<SNodeListState> ret = emptyList();
	STree<FormalParameter.State> param;
}
{
  param = InferredFormalParameter() { ret = append(ret, param); }
  ( "," param = InferredFormalParameter() { ret = append(ret, param); } )*
  { return ret; }
}

STree<FormalParameter.State> InferredFormalParameter():
{
	STree<Name.State> name;
}
{
  name = Name()
  { return makeFormalParameter(name); }
}

JAVACODE
STree<FormalParameter.State> makeFormalParameter(STree<Name.State> name) {
  return FormalParameter.make(emptyList(), UnknownType.make(), false,
    VariableDeclaratorId.make(name, emptyList())
  );
}

AssignExpr.AssignOp AssignmentOperator():
{
	AssignExpr.AssignOp ret;
}
{
  ( "="    { ret = AssignExpr.AssignOp.Normal; }
  | "*="   { ret = AssignExpr.AssignOp.Times; }
  | "/="   { ret = AssignExpr.AssignOp.Divide; }
  | "%="   { ret = AssignExpr.AssignOp.Remainder; }
  | "+="   { ret = AssignExpr.AssignOp.Plus; }
  | "-="   { ret = AssignExpr.AssignOp.Minus; }
  | "<<="  { ret = AssignExpr.AssignOp.LeftShift; }
  | ">>="  { ret = AssignExpr.AssignOp.RightSignedShift; }
  | ">>>=" { ret = AssignExpr.AssignOp.RightUnsignedShift; }
  | "&="   { ret = AssignExpr.AssignOp.And; }
  | "^="   { ret = AssignExpr.AssignOp.XOr; }
  | "|="   { ret = AssignExpr.AssignOp.Or; } )
  { return ret; }
}

STree<? extends Expr.State> ConditionalExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> left;
	STree<? extends Expr.State> right;
}
{
  ret = ConditionalOrExpression()
  [
    LOOKAHEAD(2)
    { lateRun(); } "?" left = Expression() ":" right = ConditionalExpression()
    { ret = dress(ConditionalExpr.make(ret, left, right)); }
  ]
  { return ret; }
}

STree<? extends Expr.State> ConditionalOrExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
}
{
  ret = ConditionalAndExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); } "||" right = ConditionalAndExpression()
    { ret = dress(BinaryExpr.make(ret, BinaryExpr.BinaryOp.Or, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> ConditionalAndExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
}
{
  ret = InclusiveOrExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); } "&&" right = InclusiveOrExpression()
    { ret = dress(BinaryExpr.make(ret, BinaryExpr.BinaryOp.And, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> InclusiveOrExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
}
{
  ret = ExclusiveOrExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); } "|" right = ExclusiveOrExpression()
    { ret = dress(BinaryExpr.make(ret, BinaryExpr.BinaryOp.BinOr, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> ExclusiveOrExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
}
{
  ret = AndExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); } "^" right = AndExpression()
    { ret = dress(BinaryExpr.make(ret, BinaryExpr.BinaryOp.XOr, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> AndExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
}
{
  ret = EqualityExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); } "&" right = EqualityExpression()
    { ret = dress(BinaryExpr.make(ret, BinaryExpr.BinaryOp.BinAnd, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> EqualityExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
	BinaryExpr.BinaryOp op;
}
{
  ret = InstanceOfExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); }
    ( "==" { op = BinaryExpr.BinaryOp.Equal; } |
      "!=" { op = BinaryExpr.BinaryOp.NotEqual; } )
    right = InstanceOfExpression()
    { ret = dress(BinaryExpr.make(ret, op, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> InstanceOfExpression():
{
	STree<? extends Expr.State> ret;
	STree<SNodeListState> annotations;
	STree<? extends Type.State> type;
}
{
  ret = RelationalExpression()
  [
    LOOKAHEAD(2)
    { lateRun(); } "instanceof"
    { run(); } annotations = Annotations() type = Type(annotations)
    { ret = dress(InstanceOfExpr.make(ret, type)); }
  ]
  { return ret; }
}

STree<? extends Expr.State> RelationalExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
	BinaryExpr.BinaryOp op;
}
{
  ret = ShiftExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); }
  	( "<"  { op = BinaryExpr.BinaryOp.Less; } |
  	  ">"  { op = BinaryExpr.BinaryOp.Greater; } |
  	  "<=" { op = BinaryExpr.BinaryOp.LessOrEqual; } |
  	  ">=" { op = BinaryExpr.BinaryOp.GreaterOrEqual; } )
  	right = ShiftExpression()
  	{ ret = dress(BinaryExpr.make(ret, op, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> ShiftExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
	BinaryExpr.BinaryOp op;
}
{
  ret = AdditiveExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); }
  	( "<<"             { op = BinaryExpr.BinaryOp.LeftShift; } |
  	  RSIGNEDSHIFT()   { op = BinaryExpr.BinaryOp.RightSignedShift; } |
  	  RUNSIGNEDSHIFT() { op = BinaryExpr.BinaryOp.RightUnsignedShift; } )
  	right = AdditiveExpression()
  	{ ret = dress(BinaryExpr.make(ret, op, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> AdditiveExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
	BinaryExpr.BinaryOp op;
}
{
  ret = MultiplicativeExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); }
  	( "+" { op = BinaryExpr.BinaryOp.Plus; } |
  	  "-" { op = BinaryExpr.BinaryOp.Minus; } )
  	right = MultiplicativeExpression()
  	{ ret = dress(BinaryExpr.make(ret, op, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> MultiplicativeExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Expr.State> right;
	BinaryExpr.BinaryOp op;
}
{
  ret = UnaryExpression()
  (
    LOOKAHEAD(2)
    { lateRun(); }
  	( "*" { op = BinaryExpr.BinaryOp.Times; } |
  	  "/" { op = BinaryExpr.BinaryOp.Divide; } |
  	  "%" { op = BinaryExpr.BinaryOp.Remainder; } )
  	right = UnaryExpression()
  	{ ret = dress(BinaryExpr.make(ret, op, right)); }
  )*
  { return ret; }
}

STree<? extends Expr.State> UnaryExpression():
{
	STree<? extends Expr.State> ret;
	UnaryExpr.UnaryOp op;
}
{
  (
    ret = PrefixExpression()
  |
    { run(); }
    ( "+" { op = UnaryExpr.UnaryOp.Positive; } |
      "-" { op = UnaryExpr.UnaryOp.Negative; } )
    ret = UnaryExpression()
    { ret = dress(UnaryExpr.make(op, ret)); }
  |
    ret = UnaryExpressionNotPlusMinus()
  )
  { return ret; }
}

STree<? extends Expr.State> PrefixExpression():
{
	UnaryExpr.UnaryOp op;
	STree<? extends Expr.State> ret;
}
{
  { run(); }
  ( "++" { op = UnaryExpr.UnaryOp.PreIncrement; } |
    "--" { op = UnaryExpr.UnaryOp.PreDecrement; } )
  ret = UnaryExpression()
  { return dress(UnaryExpr.make(op, ret)); }
}

STree<? extends Expr.State> UnaryExpressionNotPlusMinus():
{
	STree<? extends Expr.State> ret;
	UnaryExpr.UnaryOp op;
}
{
  (
    { run(); }
	( "~" { op = UnaryExpr.UnaryOp.Inverse; } |
	  "!" { op = UnaryExpr.UnaryOp.Not; } )
	ret = UnaryExpression()
	{ ret = dress(UnaryExpr.make(op, ret)); }
  |
    LOOKAHEAD(CastExpression())
    ret = CastExpression()
  |
    ret = PostfixExpression()
  )
  { return ret; }
}

STree<? extends Expr.State> PostfixExpression():
{
	STree<? extends Expr.State> ret;
	UnaryExpr.UnaryOp op;
}
{
  ret = PrimaryExpression()
  [
  	LOOKAHEAD(2)
    { lateRun(); }
    ( "++" { op = UnaryExpr.UnaryOp.PostIncrement; } |
      "--" { op = UnaryExpr.UnaryOp.PostDecrement; } )
    { ret = dress(UnaryExpr.make(op, ret)); }
  ]
  { return ret; }
}

STree<? extends Expr.State> CastExpression():
{
	STree<? extends Expr.State> ret;
	STree<? extends Type.State> type;
	STree<SNodeListState> types = emptyList();
	STree<SNodeListState> annotations = null;
}
{
  (
    LOOKAHEAD( "(" PrimitiveCastType() ")" )
    { run(); }
    "(" type = PrimitiveCastType() ")" ret = UnaryExpression()
    { ret = dress(CastExpr.make(type, ret)); }
  |
    { run(); }
    "(" type = ReferenceCastType() ")"
    ret = UnaryExpressionNotPlusMinus()
    { ret = dress(CastExpr.make(type, ret)); }
  )
  { return ret; }
}

STree<? extends Type.State> PrimitiveCastType():
{
	STree<? extends Type.State> type;
	STree<SNodeListState> types = emptyList();
	STree<SNodeListState> annotations = null;
}
{
  { run(); } annotations = Annotations() type = PrimitiveType(annotations)
  { return type; }
}

STree<? extends Type.State> ReferenceCastType():
{
	STree<? extends Type.State> type;
	STree<SNodeListState> types = emptyList();
	STree<SNodeListState> annotations = null;
}
{
  { run(); } annotations = Annotations() type = ReferenceType(annotations)
  { types = append(types, type); }
  [
    LOOKAHEAD("&")
    { lateRun(); }
    (
      "&"
      { run(); } annotations = Annotations() type = ReferenceType(annotations)
      { types = append(types, type); }
    )+
    { type = dress(IntersectionType.make(types)); }
  ]
  { return type; }
}

STree<? extends Expr.State> Literal():
{
	STree<? extends Expr.State> ret;
}
{
  { run(); }
  (
    <INTEGER_LITERAL>   { ret = LiteralExpr.make(Integer.class, token.image); }
  |
    <LONG_LITERAL>      { ret = LiteralExpr.make(Long.class, token.image); }
  |
    <FLOAT_LITERAL>     { ret = LiteralExpr.make(Float.class, token.image); }
  |
    <DOUBLE_LITERAL>    { ret = LiteralExpr.make(Double.class, token.image); }
  |
    <CHARACTER_LITERAL> { ret = LiteralExpr.make(Character.class, token.image); }
  |
    <STRING_LITERAL>    { ret = LiteralExpr.make(String.class, token.image); }
  |
    "true"  { ret = LiteralExpr.make(Boolean.class, token.image); }
  |
    "false" { ret = LiteralExpr.make(Boolean.class, token.image); }
  |
    "null"  { ret = LiteralExpr.make(Void.class, token.image); }
  )
  { return dress(ret); }
}

STree<? extends Expr.State> PrimaryExpression():
{
	STree<? extends Expr.State> ret;
}
{
  ret = PrimaryPrefix()
  (
    LOOKAHEAD(2)
    { lateRun(); } ret = PrimarySuffix(ret)
  )*
  { return ret; }
}

STree<? extends Expr.State> PrimaryExpressionWithoutSuperSuffix():
{
	STree<? extends Expr.State> ret;
}
{
  ret = PrimaryPrefix()
  (
    LOOKAHEAD( PrimarySuffixWithoutSuper() )
    { lateRun(); } ret = PrimarySuffixWithoutSuper(ret)
  )*
  { return ret; }
}

STree<? extends Expr.State> PrimaryPrefix():
{
	STree<? extends Expr.State> ret = null;
	STree<SNodeListState> typeArgs = null;
	STree<SNodeListState> params;
	STree<? extends Type.State> type;
}
{
  (
    ret = Literal()
  |
    { run(); } "this" { ret = dress(ThisExpr.make(none())); }
  |
    { run(); } "super" { ret = dress(SuperExpr.make(none())); }
	(
	  { lateRun(); }
	  "."
	  (
        LOOKAHEAD( [ TypeArguments() ] Name() "(" )
        ret = MethodInvocation(ret)
	  |
	    ret = FieldAccess(ret)
	  )
	|
	  { lateRun(); }
	  ret = MethodReferenceSuffix(ret)
	)
  |
    ret = AllocationExpression(null)
  |
    LOOKAHEAD( ResultType() "." "class" )
    { run(); } type = ResultType() "." "class" { ret = dress(ClassExpr.make(type)); }
  |
    LOOKAHEAD (ResultType() "::" )
    { run(); }
    type = ResultType() { ret = TypeExpr.make(type); }
    ret = MethodReferenceSuffix(ret)
  |
    LOOKAHEAD( [ TypeArguments() ] Name() "(" )
    { run(); }
    ret = MethodInvocation(null)
  |
    ret = Name()
    [
      { lateRun(); }
      "->" ret = LambdaBody(singletonList(makeFormalParameter((STree<Name.State>) ret)), false)
    ]
  |
    { run(); }
    "("
    (
      ")" "->" ret = LambdaBody(emptyList(), true)
    |
      LOOKAHEAD( Name() ")" "->" )
      ret = Name() ")" "->" ret = LambdaBody(singletonList(makeFormalParameter((STree<Name.State>) ret)), true)
    |
      LOOKAHEAD( Name() "," )
      params = InferredFormalParameterList() ")" "->" ret = LambdaBody(params, true)
    |
      LOOKAHEAD({ isLambda() })
      params = FormalParameterList() ")" "->" ret = LambdaBody(params, true)
    |
      ret = Expression() ")"
      { ret = dress(ParenthesizedExpr.make(ret)); }
    )
  )
  { return ret; }
}

STree<? extends Expr.State> PrimarySuffix(STree<? extends Expr.State> scope):
{
	STree<? extends Expr.State> ret;
}
{
  // Run is started before scope

  (
    LOOKAHEAD(2)
    ret = PrimarySuffixWithoutSuper(scope)
  |
    "." "super" { ret = dress(SuperExpr.make(optionOf(scope))); }
  |
    ret = MethodReferenceSuffix(scope)
  )
  { return ret; }
}

STree<? extends Expr.State> PrimarySuffixWithoutSuper(STree<? extends Expr.State> scope):
{
	STree<? extends Expr.State> ret;
	STree<Name.State> name;
}
{
  // Run is started before scope

  (
    "."
    (
      "this" { ret = dress(ThisExpr.make(optionOf(scope))); }
    |
      ret = AllocationExpression(scope)
    |
      LOOKAHEAD( [ TypeArguments() ] Name() "(" )
      ret = MethodInvocation(scope)
    |
      ret = FieldAccess(scope)
    )
  |
    "[" ret = Expression() "]" { ret = dress(ArrayAccessExpr.make(scope, ret)); }
  )

  { return ret; }
}

STree<? extends Expr.State> FieldAccess(STree<? extends Expr.State> scope):
{
	STree<Name.State> name;
}
{
  // Run is started before scope

  name = Name()
  { return dress(FieldAccessExpr.make(optionOf(scope), name)); }
}

STree<? extends Expr.State> MethodInvocation(STree<? extends Expr.State> scope):
{
    STree<SNodeListState> typeArgs = null;
	STree<Name.State> name;
    STree<SNodeListState> args = null;
	STree<? extends Expr.State> ret;
}
{
  // Run is started before scope

  [ typeArgs = TypeArguments() ] name = Name()
  args = Arguments()
  { return dress(MethodInvocationExpr.make(optionOf(scope), ensureNotNull(typeArgs), name, args)); }
}

STree<SNodeListState> Arguments():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Expr.State> expr;
}
{
  "("
  [
    LOOKAHEAD(1)
    expr = Expression() { ret = append(ret, expr); }
    ( "," expr = Expression() { ret = append(ret, expr); } )*
  |
    LOOKAHEAD({quotesMode}) ret = NodeListVar()
  ]
  ")"
  { return ret; }
}

STree<? extends Expr.State> MethodReferenceSuffix(STree<? extends Expr.State> scope):
{
    STree<SNodeListState> typeArgs = null;
	STree<Name.State> name;
	STree<? extends Expr.State> ret;
}
{
  // Run is started before scope

  "::" [typeArgs = TypeArguments() ]
  ( name = Name() | "new" { name = Name.make("new"); } )
  { ret = dress(MethodReferenceExpr.make(scope, ensureNotNull(typeArgs), name)); }
  { return ret; }
}

STree<? extends Expr.State> AllocationExpression(STree<? extends Expr.State> scope):
{
	STree<? extends Expr.State> ret;
	STree<? extends Type.State> type;
	STree<SNodeListState> typeArgs = null;
	STree<SNodeListState> anonymousBody = null;
	STree<SNodeListState> args;
	STree<SNodeListState> annotations = null;
}
{
  // Run may be started before scope
  { if (scope == null) run(); }

  "new"
  [ typeArgs = TypeArguments() ]

  { run(); }
  annotations = Annotations()
  (
    type = PrimitiveType(annotations)
    ret = ArrayCreationExpr(type)
  |
	type = QualifiedType(annotations)
    (
	  ret = ArrayCreationExpr(type)
	|
	  args = Arguments() [ LOOKAHEAD( "{" ) anonymousBody = ClassOrInterfaceBody(TypeKind.Class) ]
      { ret = dress(ObjectCreationExpr.make(optionOf(scope), ensureNotNull(typeArgs), (STree<QualifiedType.State>) type, args, optionOf(anonymousBody))); }
    )
  )
  { return ret; }
}

STree<? extends Expr.State> ArrayCreationExpr(STree<? extends Type.State> componentType):
{
	STree<? extends Expr.State> expr;
	STree<SNodeListState> arrayDimExprs = emptyList();
	STree<SNodeListState> arrayDims = emptyList();
	STree<SNodeListState> annotations = null;
	STree<ArrayInitializerExpr.State> initializer;
}
{
  (
    LOOKAHEAD( Annotations() "[" Expression() "]" )
    arrayDimExprs = ArrayDimExprsMandatory()
    arrayDims = ArrayDims()
    { return dress(ArrayCreationExpr.make(componentType, arrayDimExprs, arrayDims, none())); }
  |
    arrayDims = ArrayDimsMandatory()
    initializer = ArrayInitializer()
    { return dress(ArrayCreationExpr.make(componentType, arrayDimExprs, arrayDims, optionOf(initializer))); }
  )
}

STree<SNodeListState> ArrayDimExprsMandatory():
{
	STree<SNodeListState> arrayDimExprs = emptyList();
	STree<SNodeListState> annotations;
	STree<? extends Expr.State> expr;
}
{
  (
    LOOKAHEAD( Annotations() "[" Expression() "]" )
    { run(); }
    annotations = Annotations() "[" expr = Expression() "]"
    { arrayDimExprs = append(arrayDimExprs, dress(ArrayDimExpr.make(annotations, expr))); }
  )+
  { return arrayDimExprs; }
}

STree<SNodeListState> ArrayDimsMandatory():
{
	STree<SNodeListState> arrayDims = emptyList();
	STree<SNodeListState> annotations;
}
{
  (
    LOOKAHEAD( Annotations() "[" "]" )
    { run(); }
    annotations = Annotations() "[" "]"
    { arrayDims = append(arrayDims, dress(ArrayDim.make(annotations))); }
  )+
  { return arrayDims; }
}

/**********************************************************************************************************************
 * Statements
 **********************************************************************************************************************/

STree<? extends Stmt.State> Statement():
{
	STree<? extends Stmt.State> ret;
}
{
  (
	  LOOKAHEAD(2)
	  ret = LabeledStatement()
	|
	  ret = AssertStatement()
	|
	  ret = Block()
	|
	  ret = EmptyStatement()
	|
	  ret = StatementExpression()
	|
	  ret = SwitchStatement()
	|
	  ret = IfStatement()
	|
	  ret = WhileStatement()
	|
	  ret = DoStatement()
	|
	  ret = ForStatement()
	|
	  ret = BreakStatement()
	|
	  ret = ContinueStatement()
	|
	  ret = ReturnStatement()
	|
	  ret = ThrowStatement()
	|
	  ret = SynchronizedStatement()
	|
	  ret = TryStatement()
  )
  { return ret; }
}

STree<AssertStmt.State> AssertStatement():
{
	STree<? extends Expr.State> check;
	STree<? extends Expr.State> msg = null;
}
{
  { run(); }
  "assert" check = Expression() [ ":" msg = Expression() ] ";"
  { return dress(AssertStmt.make(check, optionOf(msg)));  }
}

STree<LabeledStmt.State> LabeledStatement():
{
	STree<Name.State> label;
	STree<? extends Stmt.State> stmt;
}
{
  { run(); }
  label = Name() ":" stmt = Statement()
  { return dress(LabeledStmt.make(label, stmt)); }
}

STree<BlockStmt.State> Block():
{
	STree<SNodeListState> stmts;
}
{
  { run(); }
  "{" stmts = Statements() "}"
  { return dress(BlockStmt.make(ensureNotNull(stmts))); }
}

/*
 * Classes inside block stametents can only be abstract or final. The semantic must check it.
 */
STree<? extends Stmt.State> BlockStatement():
{
	STree<? extends Stmt.State> ret;
	STree<? extends Expr.State> expr;
	STree<? extends TypeDecl.State> typeDecl;
	STree<SNodeListState> modifiers;
}
{
  (
    LOOKAHEAD( Modifiers() ("class" | "interface") )
    { run(); }
    { run(); } modifiers = Modifiers() typeDecl = ClassOrInterfaceDecl(modifiers)
    { ret = dress(TypeDeclarationStmt.make(typeDecl)); }
  |
    LOOKAHEAD( VariableDeclExpression() )
    { run(); }
    expr = VariableDeclExpression() ";"
    { ret = dress(ExpressionStmt.make(expr)); }
  |
    ret = Statement()
  )
  { return ret; }
}

STree<VariableDeclarationExpr.State> VariableDeclExpression():
{
	STree<SNodeListState> modifiers;
	STree<LocalVariableDecl.State> variableDecl;
}
{
  { run(); }
  { run(); } modifiers = Modifiers() variableDecl = VariableDecl(modifiers)
  { return dress(VariableDeclarationExpr.make(variableDecl)); }
}

STree<EmptyStmt.State> EmptyStatement():
{}
{
  { run(); }
  ";"
  { return dress(EmptyStmt.make()); }
}

STree<ExpressionStmt.State> StatementExpression():
{
	STree<? extends Expr.State> expr;
	AssignExpr.AssignOp op;
	STree<? extends Expr.State> value;
}
{
  { run(); }
  (
    expr = PrefixExpression()
  |
    expr = PrimaryExpression()
    [
      { lateRun(); } "++"
      { expr = dress(UnaryExpr.make(UnaryExpr.UnaryOp.PostIncrement, expr));  }
    |
      { lateRun(); } "--"
      { expr = dress(UnaryExpr.make(UnaryExpr.UnaryOp.PostDecrement, expr));  }
    |
      { lateRun(); } op = AssignmentOperator() value = Expression()
      { expr = dress(AssignExpr.make(expr, op, value)); }
    ]
  )
  ";"
  { return dress(ExpressionStmt.make(expr)); }
}

STree<SwitchStmt.State> SwitchStatement():
{
	STree<? extends Expr.State> selector;
	STree<SwitchCase.State> entry;
	STree<SNodeListState> entries = emptyList();
}
{
  { run(); }
  "switch" "(" selector = Expression() ")" "{"
  ( entry = SwitchEntry() { entries = append(entries, entry); } )*
  "}"
  { return dress(SwitchStmt.make(selector, entries)); }
}

STree<SwitchCase.State> SwitchEntry():
{
	STree<? extends Expr.State> label = null;
	STree<SNodeListState> stmts;
}
{
  { run(); }
  (
    "case" label = Expression()
  |
    "default"
  )
  ":" stmts = Statements()
  { return dress(SwitchCase.make(optionOf(label), ensureNotNull(stmts))); }
}

STree<IfStmt.State> IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if Stmt.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
	STree<? extends Expr.State> condition;
	STree<? extends Stmt.State> thenStmt;
	STree<? extends Stmt.State> elseStmt = null;
}
{
  { run(); }
  "if" "(" condition = Expression() ")" thenStmt = Statement() [ LOOKAHEAD(1) "else" elseStmt = Statement() ]
  { return dress(IfStmt.make(condition, thenStmt, optionOf(elseStmt))); }
}

STree<WhileStmt.State> WhileStatement():
{
	STree<? extends Expr.State> condition;
	STree<? extends Stmt.State> body;
}
{
  { run(); }
  "while" "(" condition = Expression() ")" body = Statement()
  { return dress(WhileStmt.make(condition, body)); }
}

STree<DoStmt.State> DoStatement():
{
	STree<? extends Expr.State> condition;
	STree<? extends Stmt.State> body;
}
{
  { run(); }
  "do" body = Statement() "while" "(" condition = Expression() ")" ";"
  { return dress(DoStmt.make(body, condition)); }
}

STree<? extends Stmt.State> ForStatement():
{
	STree<VariableDeclarationExpr.State> varExpr = null;
	STree<? extends Expr.State> expr = null;
	STree<SNodeListState> init = null;
	STree<SNodeListState> update = null;
	STree<? extends Stmt.State> body;
}
{
  { run(); }
  "for" "("
  (
    LOOKAHEAD(VariableDeclExpression() ":")
    varExpr = VariableDeclExpression() ":" expr = Expression()
  |
    [ init = ForInit() ] ";" [ expr = Expression() ] ";" [ update = ForUpdate() ]
  )
  ")" body = Statement()
  {
  	if (varExpr != null) return dress(ForeachStmt.make(varExpr, expr, body));
    else return dress(ForStmt.make(init, expr, update, body));
  }
}

STree<SNodeListState> ForInit():
{
	STree<SNodeListState> ret;
	STree<? extends Expr.State> expr;
}
{
  (
    LOOKAHEAD( Modifiers() Type() Name() )
    expr = VariableDeclExpression() { ret = emptyList(); ret = append(ret, expr); }
  |
    ret = ExpressionList()
  )
  { return ret; }
}

STree<SNodeListState> ExpressionList():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Expr.State> expr;
}
{
  expr = Expression() { ret = append(ret, expr); } ( "," expr = Expression()  { ret = append(ret, expr); } )*
  { return ret; }
}

STree<SNodeListState> ForUpdate():
{
	STree<SNodeListState> ret;
}
{
  ret = ExpressionList()
  { return ret; }
}

STree<BreakStmt.State> BreakStatement():
{
	STree<Name.State> id = null;
}
{
  { run(); }
  "break" [ id = Name() ] ";"
  { return dress(BreakStmt.make(optionOf(id))); }
}

STree<ContinueStmt.State> ContinueStatement():
{
	STree<Name.State> id = null;
}
{
  { run(); }
  "continue" [ id = Name() ] ";"
  { return dress(ContinueStmt.make(optionOf(id))); }
}

STree<ReturnStmt.State> ReturnStatement():
{
	STree<? extends Expr.State> expr = null;
}
{
  { run(); }
  "return" [ expr = Expression() ] ";"
  { return dress(ReturnStmt.make(optionOf(expr))); }
}

STree<ThrowStmt.State> ThrowStatement():
{
	STree<? extends Expr.State> expr;
}
{
  { run(); }
  "throw" expr = Expression() ";"
  { return dress(ThrowStmt.make(expr)); }
}

STree<SynchronizedStmt.State> SynchronizedStatement():
{
	STree<? extends Expr.State> expr;
	STree<BlockStmt.State> block;
}
{
  { run(); }
  "synchronized" "(" expr = Expression() ")" block = Block()
  { return dress(SynchronizedStmt.make(expr, block)); }
}

STree<TryStmt.State> TryStatement():
// TODO Make catchClauses/finallyClause counts less fatal
{
	STree<SNodeListState> resources = null;
	ByRef<Boolean> trailingSemiColon = new ByRef<Boolean>(false);
	STree<BlockStmt.State> tryBlock;
	STree<BlockStmt.State> finallyBlock = null;
	STree<SNodeListState> catchClauses = null;
}
{
  { run(); }
  "try"
  (
    resources = ResourceSpecification(trailingSemiColon)
    tryBlock = Block()
    [ catchClauses = CatchClauses() ]
    [ "finally" finallyBlock = Block() ]
  |
    tryBlock = Block()
    (
      catchClauses = CatchClauses()
      [ "finally" finallyBlock = Block() ]
    |
      "finally" finallyBlock = Block()
    )
  )
  { return dress(TryStmt.make(ensureNotNull(resources), trailingSemiColon.value, tryBlock, ensureNotNull(catchClauses), optionOf(finallyBlock))); }
}

STree<SNodeListState> CatchClauses():
{
	STree<SNodeListState> catchClauses = emptyList();
	STree<CatchClause.State> catchClause;
}
{
  (
    catchClause = CatchClause() { catchClauses = append(catchClauses, catchClause); }
  )+
  { return catchClauses; }
}

STree<CatchClause.State> CatchClause():
{
	STree<FormalParameter.State> param;
	STree<BlockStmt.State> catchBlock;
}
{
  { run(); }
  "catch" "(" param = CatchFormalParameter() ")" catchBlock = Block()
  { return dress(CatchClause.make(param, catchBlock)); }
}

STree<FormalParameter.State> CatchFormalParameter():
{
	STree<SNodeListState> modifiers;
	STree<? extends Type.State> exceptType;
	STree<SNodeListState> exceptTypes = emptyList();
	STree<VariableDeclaratorId.State> exceptId;
}
{
  { run(); }
  modifiers = Modifiers()

  exceptType = QualifiedType(null) { exceptTypes = append(exceptTypes, exceptType); }
  [
    LOOKAHEAD("|")
    { lateRun(); }
    ( "|" exceptType = AnnotatedQualifiedType() { exceptTypes = append(exceptTypes, exceptType); } )+
    { exceptType = dress(UnionType.make(exceptTypes)); }
  ]

  exceptId = VariableDeclaratorId()
  { return dress(FormalParameter.make(modifiers, exceptType, false, exceptId)); }
}

STree<SNodeListState> ResourceSpecification(ByRef<Boolean> trailingSemiColon) :
{
	STree<SNodeListState> vars = emptyList();
	STree<VariableDeclarationExpr.State> var;
}
{
  "("
  // FIXME this is a bit more lenient than we need to be, eg allowing access modifiers like private
  var = VariableDeclExpression() { vars = append(vars, var); }
  ( LOOKAHEAD(2) ";" var = VariableDeclExpression() {vars = append(vars, var);} )*
  [ LOOKAHEAD(2) ";" { trailingSemiColon.value = true; } ]
  ")"
  { return vars; }
}


/* We use productions to match >>>, >> and > so that we can keep the
 * type Decl syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                getToken(1).realKind == RUNSIGNEDSHIFT } )
   ">" ">" ">" { popNewWhitespaces(); }
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                getToken(1).realKind == RSIGNEDSHIFT } )
  ">" ">" { popNewWhitespaces(); }
  )
}


/**********************************************************************************************************************
 * Annotations
 **********************************************************************************************************************/

STree<SNodeListState> Annotations():
{
	STree<SNodeListState> annotations = emptyList();
	STree<? extends AnnotationExpr.State> annotation;
}
{
  ( annotation = Annotation() { annotations = append(annotations, annotation); } )*
  { return annotations; }
}

STree<? extends AnnotationExpr.State> Annotation():
{
	STree<? extends AnnotationExpr.State> ret;
}
{
  (
    LOOKAHEAD( "@" QualifiedName() "(" ( Name() "=" | ")" ))
    ret = NormalAnnotation()
  |
    LOOKAHEAD( "@" QualifiedName() "(" )
    ret = SingleMemberAnnotation()
  |
    LOOKAHEAD( "@" QualifiedName() )
    ret = MarkerAnnotation()
  )
  { return ret; }
}

STree<NormalAnnotationExpr.State> NormalAnnotation():
{
	STree<QualifiedName.State> name;
	STree<SNodeListState> pairs = null;
}
{
  { run(); }
  "@" name = QualifiedName() "(" [ pairs = MemberValuePairs() ] ")"
  { return dress(NormalAnnotationExpr.make(name, ensureNotNull(pairs))); }
}

STree<MarkerAnnotationExpr.State> MarkerAnnotation():
{
	STree<QualifiedName.State> name;
}
{
  { run(); }
  "@" name = QualifiedName()
  { return dress(MarkerAnnotationExpr.make(name)); }
}

STree<SingleMemberAnnotationExpr.State> SingleMemberAnnotation():
{
	STree<QualifiedName.State> name;
	STree<? extends Expr.State> memberVal;
}
{
  { run(); }
  "@" name = QualifiedName() "(" memberVal = MemberValue() ")"
  { return dress(SingleMemberAnnotationExpr.make(name, memberVal)); }
}

STree<SNodeListState> MemberValuePairs():
{
	STree<SNodeListState> ret = emptyList();
	STree<MemberValuePair.State> pair;
}
{
  pair = MemberValuePair() { ret = append(ret, pair); }
  ( "," pair = MemberValuePair() { ret = append(ret, pair); } )*
  { return ret; }
}

STree<MemberValuePair.State> MemberValuePair():
{
	STree<Name.State> name;
	STree<? extends Expr.State> value;
}
{
  { run(); }
  name = Name() "=" value = MemberValue()
  { return dress(MemberValuePair.make(name, value)); }
}

STree<? extends Expr.State> MemberValue():
{
	STree<? extends Expr.State> ret;
}
{
  (
    ret = Annotation()
  |
    ret = MemberValueArrayInitializer()
  |
    ret = ConditionalExpression()
  )
  { return ret; }
}

STree<? extends Expr.State> MemberValueArrayInitializer():
{
	STree<SNodeListState> ret = emptyList();
	STree<? extends Expr.State> member;
	boolean trailingComma = false;
}
{
  { run(); }
  "{"
  [
    member = MemberValue() { ret = append(ret, member); }
    ( LOOKAHEAD(2) "," member = MemberValue() { ret = append(ret, member); } )*
  ]
  [ "," { trailingComma = true; } ]
  "}"
  { return dress(ArrayInitializerExpr.make(ret, trailingComma)); }
}
